import { createContext, useMemo, useContext, useState, useCallback } from 'react';
import OpenAI from 'openai';
import { GoogleGenerativeAI } from '@google/generative-ai';
import { jsx } from 'react/jsx-runtime';

function createOpenAIProvider(opts) {
  const baseURL = opts.baseUrl || "https://openrouter.ai/api/v1";
  let model = opts.model || "openai/gpt-4o-mini";
  const isProxy = typeof baseURL === "string" && baseURL.startsWith("/");
  const client = !isProxy ? new OpenAI({
    apiKey: opts.apiKey,
    baseURL,
    dangerouslyAllowBrowser: opts.dangerouslyAllowBrowser ?? true
  }) : null;
  async function chat(messages) {
    const sys = messages.find((m) => m.role === "system" && typeof m.content === "string" && m.content.startsWith("model:"));
    if (sys) {
      const parts = sys.content.split(":");
      if (parts[1]) model = parts.slice(1).join(":").trim();
    }
    if (!isProxy && client) {
      const completion = await client.chat.completions.create({
        model,
        messages: messages.map((m) => ({ role: m.role, content: m.content })),
        extra_headers: opts.extraHeaders
      });
      const out2 = [];
      if (completion.choices && completion.choices.length) {
        for (const ch of completion.choices) {
          const content = ch.message?.content;
          if (content) {
            out2.push({ role: ch.message?.role || "assistant", content });
          }
        }
      }
      return out2;
    }
    const resp = await fetch(`${baseURL}/chat/completions`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        ...opts.extraHeaders || {}
      },
      body: JSON.stringify({ model, messages })
    });
    if (!resp.ok) {
      const text = await resp.text();
      throw new Error(`OpenAI chat (proxy) error: ${resp.status} ${text}`);
    }
    const data = await resp.json();
    const out = [];
    if (data.choices && data.choices.length) {
      for (const ch of data.choices) {
        const content = ch.message?.content;
        if (content) out.push({ role: ch.message?.role || "assistant", content });
      }
    }
    return out;
  }
  async function generateImage(prompt) {
    const headers = {
      "Content-Type": "application/json",
      ...opts.extraHeaders || {}
    };
    if (!isProxy) {
      headers["Authorization"] = `Bearer ${opts.apiKey}`;
    }
    const resp = await fetch(`${baseURL}/images/generations`, {
      method: "POST",
      headers,
      body: JSON.stringify({ prompt, n: 1, size: "1024x1024" })
    });
    if (!resp.ok) {
      const text = await resp.text();
      throw new Error(`OpenAI image error: ${resp.status} ${text}`);
    }
    const data = await resp.json();
    if (data.data && data.data[0]) {
      if (data.data[0].url) return data.data[0].url;
      if (data.data[0].b64_json) {
        const raw = data.data[0].b64_json;
        return raw.startsWith("data:") ? raw : `data:image/png;base64,${raw}`;
      }
    }
    throw new Error("OpenAI image: unexpected response");
  }
  return {
    id: "openai",
    chat,
    generateImage
  };
}
function createGeminiProvider({ apiKey, model = "gemini-1.5-pro", ...options }) {
  if (!apiKey) {
    throw new Error("Gemini provider requires apiKey.");
  }
  const genAI = new GoogleGenerativeAI(apiKey);
  const modelInstance = genAI.getGenerativeModel({ model });
  return {
    id: "gemini",
    chat: async (messages) => {
      const contents = messages.map((m) => {
        let role = m.role;
        if (role === "system") role = "user";
        if (role === "assistant") role = "model";
        return {
          role,
          parts: [{ text: m.content }]
        };
      });
      const result = await modelInstance.generateContent({ contents });
      const text = result.response.text();
      return [
        {
          role: "assistant",
          content: text
        }
      ];
    }
  };
}
var AIContext = createContext(null);
var AIProvider = ({ children, provider = "openai", apiKey, options }) => {
  const prov = useMemo(() => {
    if (provider === "openai") {
      if (!apiKey) throw new Error("OpenAI provider requires apiKey.");
      return createOpenAIProvider({ apiKey, ...options });
    }
    if (provider === "gemini") {
      if (!apiKey) throw new Error("Gemini provider requires apiKey.");
      return createGeminiProvider({ apiKey, ...options });
    }
    throw new Error(`Unknown provider: ${provider}`);
  }, [provider, apiKey, JSON.stringify(options || {})]);
  return /* @__PURE__ */ jsx(AIContext.Provider, { value: { provider: prov }, children });
};
function useAIProviderContext() {
  const ctx = useContext(AIContext);
  if (!ctx) throw new Error("useAIProviderContext must be used inside AIProvider");
  return ctx;
}
function useAI(initialSystemPrompt) {
  const { provider } = useAIProviderContext();
  const [messages, setMessages] = useState(
    initialSystemPrompt ? [{ role: "system", content: initialSystemPrompt }] : []
  );
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const sendMessage = useCallback(async (content) => {
    setLoading(true);
    setError(null);
    const next = [...messages, { role: "user", content }];
    setMessages(next);
    try {
      const replies = await provider.chat(next);
      const merged = [...next, ...replies];
      setMessages(merged);
      setLoading(false);
      return replies;
    } catch (e) {
      setError(e);
      setLoading(false);
      throw e;
    }
  }, [provider, messages]);
  return { messages, sendMessage, loading, error, setMessages };
}
function useImageAI() {
  const { provider } = useAIProviderContext();
  const [image, setImage] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const generateImage = useCallback(async (prompt) => {
    if (!provider.generateImage) throw new Error("Provider does not support image generation");
    setLoading(true);
    setError(null);
    try {
      const url = await provider.generateImage(prompt);
      setImage(url);
      setLoading(false);
      return url;
    } catch (e) {
      setError(e);
      setLoading(false);
      throw e;
    }
  }, [provider]);
  return { image, generateImage, loading, error, setImage };
}

// src/index.ts
function sum(a, b) {
  return a + b;
}

export { AIProvider, sum, useAI, useAIProviderContext, useImageAI };
//# sourceMappingURL=index.mjs.map
//# sourceMappingURL=index.mjs.map